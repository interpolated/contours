import { EndType, JoinType } from 'js-angusj-clipper/web';
import { IApartmentCalcResult, IDwelling, ISegmentOffset } from './apartments';
import { AdvancedPropertyFilter } from './filtering';
import { CalcProjectedCoordinate, Lot, RawFeatureProps, RawSection, SubdivisionMode } from './general';
type DendroFeatureProps = Record<string, any>;
export interface DendroPoint {
    type: 'Feature';
    geometry: {
        type: 'Point';
    };
    _projected: CalcProjectedCoordinate;
    properties: DendroFeatureProps;
    _transform?: Transform;
    _path?: string;
}
export interface DendroLineString {
    type: 'Feature';
    geometry: {
        type: 'LineString';
    };
    _projected: CalcProjectedCoordinate[];
    properties: DendroFeatureProps;
    _transform?: Transform;
    _path?: string;
    _chensApartmentAlgo?: IApartmentCalcResult;
}
export interface DendroMultiLineString {
    type: 'Feature';
    geometry: {
        type: 'MultiLineString';
    };
    _projected: CalcProjectedCoordinate[][];
    properties: DendroFeatureProps;
}
export interface DendroPolygon {
    type: 'Feature';
    geometry: {
        type: 'Polygon';
    };
    _projected: CalcProjectedCoordinate[][];
    properties: DendroFeatureProps;
    _projectedChildren?: DendroSection[];
    _display?: DendroMultiLineString | DendroLineString;
    _transform?: Transform;
    _path?: string;
    _subdivideLots?: Lot[];
}
export type DendroSection = DendroPolygon | DendroLineString | DendroPoint;
export declare const isDendroPolygon: (d: DendroSection) => d is DendroPolygon;
export type DendroLeaf = {
    properties?: Partial<RawFeatureProps>;
    ignoreInheritedProps?: boolean;
    displayName?: string;
};
export declare const BaseDendroLeafKeys: string[];
export type DendroNode = {
    children: (DendroNode | DendroLeaf)[];
    transform: Transform;
};
export type DendroRoot = {
    children: (DendroNode | DendroLeaf)[];
} | Record<string, never>;
export type DendroLeafWithFeature = {
    [x: string]: any;
    properties?: Partial<RawFeatureProps>;
    featuresWithCategory: DendroSectionWithCategory;
};
export type DendroNodeWithFeature = {
    children: (DendroNodeWithFeature | DendroLeafWithFeature)[];
    transform: Transform;
    featuresWithCategory: DendroSectionWithCategory;
};
export type DendrogramWithCalculated = DendroNodeWithFeature | DendroLeafWithFeature;
export type DendroOutputCategory = string;
export type DendroSectionWithCategory = Record<DendroOutputCategory, DendroSection[]>;
export type Transformer = (input: DendroSection[], transform?: Transform) => DendroSectionWithCategory;
export type DendroFormContext = 'narrow' | 'dendro' | 'derivate';
export interface DendrogramTransformForm<T extends Transform, F extends RawSection = RawSection> {
    baseFeature: F;
    node?: any;
    nodePath: string;
    transform: T;
    context?: DendroFormContext;
    onSubmit: (transform: T, keyMap?: (string | undefined)[][], isFast?: boolean) => void;
}
interface TransformBase {
    displayName?: string;
    showInNarrowEditor?: boolean;
    inputKeys?: DendroOutputCategory[];
    isflatOutput?: boolean;
    forwardProps?: boolean;
}
export interface CornerTransform extends TransformBase {
    type: 'roundCorners';
    parameters: {
        method: 'fillet' | 'chamfer' | 'bezier';
        radius: number;
        concave?: boolean;
        convex?: boolean;
    };
}
export interface EnclosedPolysTransform extends TransformBase {
    type: 'enclosedPolys';
}
export interface BooleanDifference extends TransformBase {
    type: 'booleanDifference';
}
export interface ExplodeTransform extends TransformBase {
    type: 'explode';
}
export interface OffsetPolyTransform extends TransformBase {
    type: 'offsetPoly';
    parameters: {
        delta: number;
        joinType?: JoinType;
        endType?: EndType;
        miterLimit?: number;
        withHoles?: boolean;
        offsetSide?: 'left' | 'right' | 'both';
    };
}
export interface OffsetLineTransform extends TransformBase {
    type: 'offsetLine';
    parameters: {
        delta: number;
        left?: boolean;
        createPoly?: boolean;
        simplePoly?: boolean;
    };
}
export interface PointsAlongLineTransform extends TransformBase {
    type: 'alongPoint';
    parameters: {
        percentsAlong?: number[];
        rotateToLine?: boolean;
    };
}
export interface StripTransform extends TransformBase {
    type: 'strip';
    parameters: {
        startCount: number;
        endCount: number;
    };
}
export interface PolyLabelTransform extends TransformBase {
    type: 'polylabel';
}
export interface PolyCentroidTransform extends TransformBase {
    type: 'centroid';
}
export interface RandomFillTransform extends TransformBase {
    type: 'randomFill';
    parameters: {
        count: number;
        seed?: string;
        scaleRangePct?: number;
    };
}
export interface ArrayTransform extends TransformBase {
    type: 'array';
    parameters: {
        spacing: number[] | number;
        offset?: number;
        cornerDistance?: number;
        cornerDistanceIsNormal?: boolean;
        rotateToLine?: boolean;
        scaleRangePct?: number;
    };
}
export interface StrokeDashTransform extends TransformBase {
    type: 'strokeDash';
    parameters: {
        spacing: number[];
        offset?: number;
        cornerDistance?: number;
        cornerDistanceIsNormal?: boolean;
    };
}
export interface LineShortenTransform extends TransformBase {
    type: 'lineShorten';
    parameters: {
        startOffset: number;
        endOffset: number;
        mergeStartAndEnd: boolean;
    };
}
export interface GridFillTransform extends TransformBase {
    type: 'gridFill';
    parameters: {
        xPattern: number[];
        yPattern: number[];
        xOffset: number;
        yOffset: number;
        inset?: number;
        edgeIndex?: number;
        generatePoints?: boolean;
        pointsOnBoundary?: boolean;
        pointsOnExclusionBoundary?: boolean;
        pointRadius: number;
        generateLines?: boolean;
        breakLines?: boolean;
    };
}
export interface ApartmentTransform extends TransformBase {
    type: 'apartment';
    parameters: {
        buildingID?: string;
        depth: number;
        leftDepth: number;
        rightDepth: number;
        startDepth: number;
        endDepth: number;
        segmentOffsets?: ISegmentOffset[];
        areaPattern?: number[];
        indexPattern?: number[];
        leftDepthPattern?: number[];
        rightDepthPattern?: number[];
        plans: IDwelling[];
        balconyUnits?: IDwelling['key'][];
        balconyInternalOffset?: number;
        balconyExternalOffset?: number;
        balconyStartOffset?: number;
        balconyEndOffset?: number;
    };
}
export interface CarparkTransform extends TransformBase {
    type: 'parkingLots';
    parameters: {
        bayLength: number;
        bayWidth: number;
        roadWidth: number;
        islandPeriod: number;
        islandSize: number;
        edgeOffset: number;
        bayTwist: number;
        longEdgeFlag: boolean;
    };
}
export interface SubdivisionTransform extends TransformBase {
    type: 'subdivideLots';
    parameters: {
        targetArea: number;
        minimumArea: number;
        endcapTargetArea: number;
        endcapMinimumArea: number;
        hasSpine: boolean;
        flip: boolean;
        targetFrontage: number;
        minimumFrontage: number;
        endcapTargetFrontage: number;
        endcapMinimumFrontage: number;
        mode: SubdivisionMode;
        generateInnerShape: boolean;
        frontSetback: number;
        rearSetback: number;
        sideSetback: number;
        cornerIsSide?: boolean;
    };
}
export interface RoadTransform extends TransformBase {
    type: 'roads';
    parameters: {
        roadColor: string;
        pavementColor: string;
        roadHeight: number;
        pavementHeight: number;
    };
}
export interface RainbowTransform extends TransformBase {
    type: 'rainbows';
    parameters: {
        radius: number;
        colors: string[];
        offsets?: number[];
        spaces?: number[];
    };
}
export interface FilterTransform extends TransformBase {
    type: 'filter';
    parameters: {
        filterDef: AdvancedPropertyFilter;
        indices?: number[];
    };
}
export interface EdgeSelectorTransform extends TransformBase {
    type: 'edgeSelector';
    parameters: {
        indices?: number[];
    };
}
export type Transform = CornerTransform | OffsetPolyTransform | OffsetLineTransform | PointsAlongLineTransform | PolyLabelTransform | PolyCentroidTransform | BooleanDifference | EnclosedPolysTransform | ExplodeTransform | EdgeSelectorTransform | RandomFillTransform | ArrayTransform | StripTransform | StrokeDashTransform | LineShortenTransform | GridFillTransform | ApartmentTransform | CarparkTransform | SubdivisionTransform | RainbowTransform | FilterTransform | RoadTransform;
export declare const hasMultipleOutputTypes: (transform?: Transform) => boolean;
export {};
