"use strict";
/* tslint:disable no-any no-unsafe-any */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MiniIframeRPC = exports.ResultCache = void 0;
const errors_1 = require("./errors");
const result_cache_1 = require("./result-cache");
Object.defineProperty(exports, "ResultCache", { enumerable: true, get: function () { return result_cache_1.ResultCache; } });
const post_message_transport_1 = require("./transport/post-message-transport");
const RANDOM_BASE = 36;
const CALLID_LENGTH = 8;
const DEFAULT_INVOCATION_OPTIONS = {
    timeout: 10 * 60 * 1000,
    retryLimit: 0,
    retryAllFailures: false,
    targetWindow: window.parent,
    targetOrigin: '*'
};
class MiniIframeRPC {
    constructor(initParameters) {
        this.events = [];
        this.callbacks = {};
        this.registeredProcedures = {};
        this.recv = (messageBody, messageSource, messageOrigin) => {
            this.internalEventCallback('onReceive', messageBody, messageSource, messageOrigin);
            if ('method' in messageBody) {
                this.handleRequest(messageBody, messageSource, messageOrigin);
            }
            else {
                this.handleResponse(messageBody);
            }
        };
        this.config = {
            windowRef: (initParameters && initParameters.windowRef) || window,
            originWhitelist: (initParameters && initParameters.originWhitelist) || [],
            defaultInvocationOptions: Object.assign({}, DEFAULT_INVOCATION_OPTIONS, (initParameters && initParameters.defaultInvocationOptions) || {}),
            eventCallbacks: (initParameters && initParameters.eventCallbacks) || {},
            resultCacheCapacity: initParameters && typeof initParameters.resultCacheCapacity === 'number'
                ? initParameters.resultCacheCapacity
                : result_cache_1.DEFAULT_RESULT_CACHE_CAPACITY
        };
        this.resultCache = new result_cache_1.ResultCache({
            capacity: this.config.resultCacheCapacity,
            evictionCallback: (id, result) => {
                this.internalEventCallback('onResultCacheEviction', id, result);
            }
        });
        this.transport = new post_message_transport_1.PostMessageTransport(this.config.windowRef, this.recv, {
            originWhitelist: this.config.originWhitelist
        });
    }
    register(procedureName, implementation) {
        this.internalEventCallback('onRegister', procedureName, implementation);
        if (implementation) {
            this.registeredProcedures[procedureName] = implementation;
        }
        else {
            delete this.registeredProcedures[procedureName];
        }
    }
    invoke(method, params, invocationOptions) {
        var _a, _b;
        const options = Object.assign({}, this.config.defaultInvocationOptions, invocationOptions || {});
        // used to be
        const targetWindow = (_a = options.targetWindow) !== null && _a !== void 0 ? _a : DEFAULT_INVOCATION_OPTIONS.targetWindow;
        const targetOrigin = (_b = options.targetOrigin) !== null && _b !== void 0 ? _b : DEFAULT_INVOCATION_OPTIONS.targetOrigin;
        const id = this.getNextCallId();
        const requestMessageBody = {
            id,
            method,
            params: params || []
        };
        return this.requestWithRetry(targetWindow, targetOrigin, requestMessageBody, options);
    }
    close() {
        this.internalEventCallback('onClose');
        this.transport.close();
    }
    requestWithRetry(targetWindow, targetOrigin, requestMessageBody, options) {
        let requestCount = 0;
        let failureCount = 0;
        let finalResolve = () => void 0;
        let finalReject = () => void 0;
        let completed = false;
        const previousRejectReasons = [];
        const isErrorRetriable = (error) => {
            if (options.timeout <= 0 || options.retryLimit < 1) {
                return false;
            }
            return options.retryAllFailures || error instanceof errors_1.TimeoutError;
        };
        const makeRequest = () => __awaiter(this, void 0, void 0, function* () {
            return this.sendMessage(targetWindow, targetOrigin, requestMessageBody).then(() => new Promise((resolve, reject) => {
                this.callbacks[requestMessageBody.id] = { resolve, reject };
            }));
        });
        const handleResolve = (result) => {
            // first successful request immediately resolves the invocation promise
            completed = true;
            finalResolve(result);
        };
        const handleReject = (reason) => {
            failureCount += 1;
            // If request has since been completed, do nothing
            // Retry request or fail permanently if no outstanding requests still in flight
            if (!completed && failureCount === requestCount) {
                if (isErrorRetriable(reason) && requestCount < options.retryLimit + 1) {
                    this.internalEventCallback('onRequestRetry', reason, previousRejectReasons, requestMessageBody);
                    previousRejectReasons.push(reason);
                    makeAttempt();
                    // If error is non-retriable and there are no unanswered requests, give up.
                }
                else {
                    completed = true;
                    finalReject(new errors_1.InvocationError(requestMessageBody.method, reason, previousRejectReasons));
                }
            }
            // if there are still outstanding requests, wait for them to succeed or fail.
        };
        const makeAttempt = () => {
            requestCount += 1;
            let responsePromise = makeRequest();
            if (options.timeout > 0) {
                responsePromise = this.timeboxPromise(responsePromise, options.timeout);
            }
            responsePromise.then(handleResolve, handleReject);
        };
        const returnValue = new Promise((resolve, reject) => {
            finalResolve = resolve;
            finalReject = reject;
        });
        // initial attempt
        makeAttempt();
        return returnValue;
    }
    internalEventCallback(internalEventCallback, ...args) {
        const cb = this.config.eventCallbacks[internalEventCallback];
        if (cb) {
            cb.apply(this, args);
        }
    }
    timeboxPromise(originalPromise, timeoutMilliSeconds) {
        return Promise.race([
            originalPromise,
            new Promise((_resolve, reject) => {
                this.config.windowRef.setTimeout(() => reject(new errors_1.TimeoutError({ timeoutMilliSeconds })), timeoutMilliSeconds);
            })
        ]);
    }
    getNextCallId() {
        let randomId = null;
        while (!randomId || this.callbacks[randomId]) {
            randomId = `cb${Math.random()
                .toString(RANDOM_BASE)
                .replace(/[^a-z]+/g, '')
                .substr(0, CALLID_LENGTH)}`;
        }
        return randomId;
    }
    sendMessage(targetWindow, targetOrigin, messageBody) {
        this.internalEventCallback('onSend', messageBody, targetWindow, targetOrigin);
        return this.transport.send({ targetWindow, targetOrigin }, messageBody);
    }
    isArray(arg) {
        // Array.isArray doesn't work in IE8 and doesn't necessarily work cross-window
        // from: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray
        return Object.prototype.toString.call(arg) === '[object Array]';
    }
    unpackParams(params) {
        if (this.isArray(params)) {
            return params;
        }
        if (params === undefined) {
            return [];
        }
        return [params];
    }
    handleRequest(requestMessageBody, messageSource, messageOrigin) {
        return __awaiter(this, void 0, void 0, function* () {
            this.events.push(new Date());
            const id = requestMessageBody.id;
            const method = requestMessageBody.method;
            const params = this.unpackParams(requestMessageBody.params);
            const responseOrigin = !messageOrigin || messageOrigin === 'null' ? null : messageOrigin;
            const sendError = (rejectOrError, exceptionName) => {
                const sendingError = (0, errors_1.isError)(rejectOrError);
                return this.sendMessage(messageSource, responseOrigin, {
                    id,
                    isErrorInstance: sendingError,
                    error: sendingError ? (0, errors_1.serializeRemoteError)(rejectOrError, exceptionName) : rejectOrError
                });
            };
            const getResult = () => {
                if (this.resultCache.hasCachedResult(id)) {
                    return this.resultCache.getCachedResult(id);
                }
                const resultPromise = new Promise(resolve => {
                    // @ts-ignore
                    resolve(this.registeredProcedures[method].apply({ requestMessageBody, messageSource, messageOrigin }, params));
                });
                this.resultCache.setCachedResult(id, resultPromise);
                return resultPromise;
            };
            const now = new Date();
            // @ts-ignore limit too 100 a minute
            this.events = this.events.filter(e => now - e < 1000 * 60);
            const MAX_PER_MINUTE = 100;
            if (this.events.length > MAX_PER_MINUTE) {
                // TODO prompt apptoaster error
                sendError(new Error(`Too many invocations, max of ${MAX_PER_MINUTE} per minute`));
            }
            else if (this.registeredProcedures[method]) {
                getResult().then((result) => this.sendMessage(messageSource, responseOrigin, {
                    id,
                    result
                }).catch(error => sendError(error, errors_1.SendMessageError.name)), (error) => sendError(error, errors_1.EvaluationError.name));
            }
            else {
                sendError(new errors_1.ProcedureNotFoundError({ procedureName: method }));
            }
        });
    }
    handleResponse(messageBody) {
        const callbackFunctions = this.callbacks[messageBody.id];
        if (callbackFunctions) {
            delete this.callbacks[messageBody.id];
            if ('isErrorInstance' in messageBody) {
                const errorObject = messageBody.isErrorInstance ? (0, errors_1.deserializeRemoteError)(messageBody.error) : messageBody.error;
                callbackFunctions.reject(errorObject);
            }
            else if ('result' in messageBody) {
                callbackFunctions.resolve(messageBody.result);
            }
        }
        else {
            this.internalEventCallback('onUnexpectedResponse', messageBody);
        }
    }
}
exports.MiniIframeRPC = MiniIframeRPC;
//# sourceMappingURL=mini-iframe-rpc.js.map