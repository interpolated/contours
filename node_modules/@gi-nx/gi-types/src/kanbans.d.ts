import { FillExtrusionLayer, FillLayer, FillPaint, LineLayer, SymbolLayer } from 'mapbox-gl';
import { AdvancedFeatureFilter, AdvancedPropertyFilter } from './filtering';
export declare const CATEGORICAL_PALETTES: readonly ["Category10", "Accent", "Dark2", "Paired", "Pastel1", "Pastel2", "Set1", "Set2", "Set3", "Tableau10", "css"];
export declare const CONTINUOUS_PALETTES: readonly ["Blues", "Greens", "Greys", "Oranges", "Purples", "Reds", "BuGn", "BuPu", "GnBu", "OrRd", "PuBuGn", "PuBu", "PuRd", "RdPu", "YlGnBu", "YlGn", "YlOrBr", "YlOrRd", "Cividis", "Viridis", "Inferno", "Magma", "Plasma", "Warm", "Cool", "CubehelixDefault", "Turbo", "BrBG", "PRGn", "PiYG", "PuOr", "RdBu", "RdGy", "RdYlBu", "RdYlGn", "Spectral", "Rainbow", "Sinebow"];
export declare const isFixedColor: (colorConfig: ColorPalette | FixedColor | undefined) => colorConfig is FixedColor;
export declare const isNumericPalette: (colorConfig: ColorPalette | FixedColor | undefined) => colorConfig is NumericalPalette;
export declare const isCategoricalPalette: (colorConfig: ColorPalette | FixedColor | undefined) => colorConfig is CategoricalPalette;
export interface NumericalPalette {
    propertyKey: string;
    scaleFunc: 'scaleLinear';
    paletteMap: Array<{
        color: string;
        value: number;
    }>;
    paletteId: (typeof CONTINUOUS_PALETTES)[number];
    fallbackColor: string;
    /**
     *  TODO deprecate - could keep paletteId as record
     * @deprecated
     */
    domain?: [number, number];
}
export interface CategoricalPalette {
    propertyKey: string;
    scaleFunc: 'scaleOrdinal';
    paletteMap: Array<{
        color: string;
        value: string;
    }>;
    fallbackColor: string;
    paletteId: (typeof CATEGORICAL_PALETTES)[number];
    /**
     *  TODO deprecate
     * @deprecated
     */
    paletteOverrides?: Record<string, string>;
}
export interface FixedColor {
    fixedValue: FillPaint['fill-color'];
}
export type ColorPalette = NumericalPalette | CategoricalPalette;
export type ColorPaletteOrFixed = FixedColor | NumericalPalette | CategoricalPalette;
export type PaletteScale<V extends string | number = string | number> = {
    color: string;
    value: V;
}[];
interface StyleBase {
    /**
     * keys displayed for each item
     *
     */
    displayKeys?: string[];
    filter?: AdvancedFeatureFilter;
}
export type PropToProp = {
    mapboxProp: string;
    featureProp: string;
    mOrPix?: 'm' | 'pix';
};
export type LensPaletteKey = 'mainColor' | 'lineColor' | 'textColor' | 'textHaloColor' | 'iconColor' | 'iconHaloColor';
export interface GiraffeVectorLayerStyle extends StyleBase {
    mainColor?: ColorPaletteOrFixed;
    mainLayer?: 'fill' | 'fill-extrusion' | 'circle' | 'icon' | 'giraffe-baked';
    fillOpacity?: number;
    circleRadius?: number;
    baseHeightKey?: string;
    heightKey?: string;
    heightScale?: number;
    showLines?: boolean;
    lineColor?: ColorPaletteOrFixed;
    lineWidth?: number;
    lineDimension?: 'meters' | 'pixels';
    showLabels?: boolean;
    textColor?: ColorPaletteOrFixed;
    textHaloColor?: ColorPaletteOrFixed;
    iconColor?: ColorPaletteOrFixed;
    iconHaloColor?: ColorPaletteOrFixed;
    clusterColor?: string;
    cluster?: boolean;
    iconImage?: string;
    iconSize?: number;
    promoteId?: string;
    sourceLayer?: string;
    props?: PropToProp[];
    overrideFill?: Partial<FillLayer>;
    overrideFillExtrusion?: Partial<FillExtrusionLayer>;
    overrideLine?: Partial<LineLayer>;
    overrideSymbol?: Partial<SymbolLayer>;
}
interface TableBase {
    sortBy?: string | null;
    sortDescending?: boolean;
    showTable?: boolean;
    showPalette?: LensPaletteKey;
    /**
     * numeric key summed and displayed at end of column
     */
    aggregateBy?: string;
    tableColumnWidths?: Record<string, number>;
    /**
     * opt-in to show specific columns
     */
    columnKeys?: string[];
}
interface KanbanDisplay extends StyleBase, TableBase {
    mainColor?: ColorPaletteOrFixed;
    columnsBy?: string;
    columns: {
        [columnName: string]: {
            cardMoves?: Array<[projectId: string, cardIndex: number]>;
        };
    };
    columnMoves: Array<[columnName: string, columnIndex: number]>;
    otherWorkspaces?: string[];
}
export type OverloadedBoard = KanbanDisplay & GiraffeVectorLayerStyle;
export interface Kanban {
    name: string;
    id: string;
    org: number | string;
    board: OverloadedBoard;
}
export type UnsavedKanban = Omit<Kanban, 'id'>;
export type VectorLayerLens = GiraffeVectorLayerStyle & TableBase;
/**
 * defines views for the usage table
 */
export interface UsageViewInKanbanTable {
    name: string;
    id: string | 'scratchTableView';
    org: string;
    usageTable: {
        sortBy: string;
        sortDescending: boolean;
        /**
         * keysToHide
         */
        hideKeys?: string[];
        /**
         * new Apr22: filter projects by properties
         */
        propFilter?: AdvancedPropertyFilter;
        /**
         * new jun22: big filter on property type for usages
         */
        usageCategoryFilter?: 'data' | 'all' | 'visual' | 'user';
        /**
         * for usage table initially (could also be used for projects table in admin)
         */
        tableColumnWidths?: Record<string, number>;
    };
}
export {};
