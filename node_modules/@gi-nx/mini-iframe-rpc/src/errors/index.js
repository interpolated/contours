"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.deserializeRemoteError = exports.serializeRemoteError = exports.InvocationError = exports.RemoteError = exports.SendMessageError = exports.isError = exports.TimeoutError = exports.EvaluationError = exports.ProcedureNotFoundError = exports.MiniIframeError = void 0;
const evaluation_error_1 = require("./evaluation-error");
Object.defineProperty(exports, "EvaluationError", { enumerable: true, get: function () { return evaluation_error_1.EvaluationError; } });
const invocation_error_1 = require("./invocation-error");
Object.defineProperty(exports, "InvocationError", { enumerable: true, get: function () { return invocation_error_1.InvocationError; } });
const is_error_1 = require("./is-error");
Object.defineProperty(exports, "isError", { enumerable: true, get: function () { return is_error_1.isError; } });
const mini_iframe_error_1 = require("./mini-iframe-error");
Object.defineProperty(exports, "MiniIframeError", { enumerable: true, get: function () { return mini_iframe_error_1.MiniIframeError; } });
const procedure_not_found_error_1 = require("./procedure-not-found-error");
Object.defineProperty(exports, "ProcedureNotFoundError", { enumerable: true, get: function () { return procedure_not_found_error_1.ProcedureNotFoundError; } });
const remote_error_1 = require("./remote-error");
Object.defineProperty(exports, "RemoteError", { enumerable: true, get: function () { return remote_error_1.RemoteError; } });
const send_message_error_1 = require("./send-message-error");
Object.defineProperty(exports, "SendMessageError", { enumerable: true, get: function () { return send_message_error_1.SendMessageError; } });
const timeout_error_1 = require("./timeout-error");
Object.defineProperty(exports, "TimeoutError", { enumerable: true, get: function () { return timeout_error_1.TimeoutError; } });
const errorMap = {};
const remoteErrorClasses = [procedure_not_found_error_1.ProcedureNotFoundError, evaluation_error_1.EvaluationError, send_message_error_1.SendMessageError].reduce((obj, constr) => {
    obj[constr.name] = constr;
    return obj;
}, errorMap);
const serializeRemoteError = (cause, remoteExceptionName) => {
    const convert = (err) => {
        const errJSON = (0, remote_error_1.errorToJSON)(err);
        if (remoteExceptionName) {
            errJSON.name = remoteExceptionName;
        }
        return errJSON;
    };
    if (cause instanceof remote_error_1.RemoteError) {
        // if cause is already a remoteError, return as is
        return convert(cause);
    }
    // for both Error and String type causes, create a new RemoteError
    return convert(new remote_error_1.RemoteError(cause));
};
exports.serializeRemoteError = serializeRemoteError;
// tslint:disable-next-line:no-any
const deserializeRemoteError = (error) => {
    const constr = remoteErrorClasses[error.name] || remote_error_1.RemoteError;
    return new constr(error);
};
exports.deserializeRemoteError = deserializeRemoteError;
//# sourceMappingURL=index.js.map