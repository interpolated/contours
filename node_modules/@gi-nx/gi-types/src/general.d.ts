import { Units } from '@turf/helpers';
import type { FeatureCollection, GeoJsonGeometryTypes } from 'geojson';
import { GeoJSONSourceRaw } from 'mapbox-gl';
import { BBox } from 'rbush';
import { DendroLineString, DendroMultiLineString, DendroOutputCategory, DendroRoot } from './dendrogram';
import { NullProjectBoundary, ProjectBoundary } from '.';
import { LayerTree } from './layers';
import { ProjectApp, ProjectTerrainSettings } from './project-apps';
import { Marker } from './sectionProperties';
import { Camera } from './three';
/**
 * Not all GeoJSON types are supported
 */
export type GiGeometryType = Exclude<GeoJsonGeometryTypes, 'GeometryCollection'>;
/**
 * Not all GeoJSON types are supported
 */
export type GeoCoordinate = [latitude: number, longitude: number];
export type CalcProjectedCoordinate = [x: number, y: number];
export type ScreenProjectedCoordinate = [x: number, y: number];
export type AnyCoordinate = GeoCoordinate | CalcProjectedCoordinate | ScreenProjectedCoordinate;
export interface GeoProject {
    forward: (coord: GeoCoordinate) => CalcProjectedCoordinate;
    inverse: (coord: CalcProjectedCoordinate) => GeoCoordinate;
}
interface PointGeometry {
    type: 'Point';
    coordinates: GeoCoordinate;
}
interface LineStringGeometry {
    type: 'LineString';
    coordinates: GeoCoordinate[];
}
interface PolygonGeometry {
    type: 'Polygon';
    coordinates: GeoCoordinate[][];
}
export interface GeoJsonPolygon {
    type: 'Feature';
    geometry: PolygonGeometry;
    properties: Record<string, any>;
}
interface GeoJsonLineString {
    type: 'Feature';
    geometry: LineStringGeometry;
    properties: Record<string, any>;
}
interface GeoJsonPoint {
    type: 'Feature';
    geometry: PointGeometry;
    properties: Record<string, any>;
}
export type GeoJsonFeature = GeoJsonPolygon | GeoJsonLineString | GeoJsonPoint;
export interface RawPolygon extends GeoJsonPolygon {
    properties: RawFeatureProps;
    versionId?: number;
}
export interface RawLineString extends GeoJsonLineString {
    properties: RawFeatureProps;
    versionId?: number;
}
export interface RawPoint extends GeoJsonPoint {
    properties: RawFeatureProps;
    versionId?: number;
}
export type RawSection = RawPolygon | RawLineString | RawPoint;
export type RawSectionCreateInput = Omit<RawSection, 'properties'> & {
    properties: Omit<RawSection['properties'], 'id'>;
};
export type GiMapboxGeoJsonFeature = GeoJsonFeature & {
    /**
     * WARNING
     * this is usually type `Layer` from mapbox-gl but for some reason using it completely borks typescript in vscode
     */
    layer: any;
    source: string;
    sourceLayer: string;
    state: {
        [key: string]: any;
    };
};
export type GiGeoJSONSourceFeatureCollectionOnly = Omit<GeoJSONSourceRaw, 'data'> & {
    data: FeatureCollection;
};
export type GiGeoJSONSourceWithExtras = GiGeoJSONSourceFeatureCollectionOnly & {
    id: string;
    key: string;
};
export type FeatureId = string;
export declare const SECTION_TYPES: {
    readonly LOT: "lot";
    readonly BUILDING_SECTION: "buildingSection";
    readonly ROAD: "road";
    readonly LANDSCAPE: "landscape";
    readonly PAVED_AREA: "paving";
    readonly BASEMENT: "basement";
    readonly LAND_USE: "landUse";
    readonly POINT: "genericPoint";
    readonly LINE: "genericLine";
    readonly POLYGON: "genericPolygon";
    readonly IMAGE: "image";
    readonly THREE_D: "3d";
    readonly REFERENCE: "reference";
    readonly BLUSH: "blush";
    readonly ARROW: "arrow";
};
export type SectionType = (typeof SECTION_TYPES)[keyof typeof SECTION_TYPES];
export declare enum SubdivisionMode {
    FRONTAGE = "frontage",
    AREA = "area"
}
export interface RawFeatureProps extends Record<string, any> {
    id: FeatureId;
    /**
     * @deprecated
     */
    appId?: string;
    layerId?: string;
    projectId: string;
    /**
     * @deprecated
     */
    public: true;
    type?: SectionType;
    dendrogram?: DendroRoot;
    marker: Marker;
    usage?: string;
    landUses?: LandUse[];
    landUseGroupId?: string;
    landUseGroupNetArea?: {
        [usage: string]: number;
    };
    childFeatures?: any[];
    inputKeys?: DendroOutputCategory[];
}
export interface PreStackedFeatureProps extends RawFeatureProps {
    ix: number;
    /**
     * @deprecated
     */
    appId: string;
    layerId: string;
    length?: number;
    grossArea?: number;
    grossBuildingArea?: number;
    netArea?: number | null;
    saleableArea?: number | null;
    perimeter?: number;
    _opacity: number;
}
export interface StackedFeatureProps extends PreStackedFeatureProps {
    _baseHeight: number;
    _height: number;
    _baseElevation: number;
    buildingID: string;
}
export interface StackedFeatureBbox extends BBox {
    id: FeatureId;
    isStacked: boolean;
    layerId: string;
}
export interface Parking {
    type: 'Feature';
    geometry: {
        type: 'MultiLineString';
        coordinates: GeoCoordinate[][];
    };
    properties: {
        parentId: FeatureId;
        height: number;
        stroke: 'white';
        strokeWidth: 1;
    };
}
export interface DendroMultiLineStringWithCoordinates extends Omit<DendroMultiLineString, 'geometry'> {
    geometry: {
        type: 'MultiLineString';
        coordinates: GeoCoordinate[][];
    };
}
export interface DendroLineStringWithCoordinates extends Omit<DendroLineString, 'geometry'> {
    geometry: {
        type: 'LineString';
        coordinates: GeoCoordinate[];
    };
}
export interface Lot {
    coords: CalcProjectedCoordinate[];
    innerCoords: CalcProjectedCoordinate[];
    frontage: number;
    area: number;
    frontageCenter: CalcProjectedCoordinate;
    isEndcap?: boolean;
}
export interface Subdivision {
    lots: Lot[];
    spine: CalcProjectedCoordinate[];
    lotCount: number;
}
export interface PreStackedPoint {
    _projected: CalcProjectedCoordinate;
    _projectedChildren?: PreStackedSection[];
    _path?: string;
    type: 'Feature';
    geometry: PointGeometry;
    properties: PreStackedFeatureProps;
}
export interface PreStackedLineString {
    _projected: CalcProjectedCoordinate[];
    _projectedChildren?: PreStackedSection[];
    _path?: string;
    type: 'Feature';
    geometry: LineStringGeometry;
    properties: PreStackedFeatureProps;
}
export interface PreStackedPolygon {
    _projected: CalcProjectedCoordinate[][];
    _projectedChildren?: PreStackedSection[];
    _path?: string;
    _display?: DendroMultiLineStringWithCoordinates | DendroLineStringWithCoordinates;
    type: 'Feature';
    geometry: PolygonGeometry;
    properties: PreStackedFeatureProps;
}
export interface StackedPoint extends Omit<PreStackedPoint, 'properties'> {
    properties: StackedFeatureProps;
}
export type StackedLineString = PreStackedLineString;
export interface StackedPolygon extends Omit<PreStackedPolygon, 'properties'> {
    properties: StackedFeatureProps;
}
export type PreStackedSection = PreStackedPoint | PreStackedLineString | PreStackedPolygon;
export type StackedSection = StackedPoint | StackedLineString | StackedPolygon;
export interface LandUse {
    /**
     * the usage name
     */
    name: string;
    /**
     * Percentage of site area as 0 - 100. Note must divide by 100 for maffs
     */
    proportion: number;
}
export interface LandUseGroup {
    id: string;
    title: string;
    /**
     * layer to which this group belongs. short layerId like those used for sections
     */
    layerId: string;
    /**
     * dominant layer proportion-wise. drives appearance of the section on the map, mostly just to show the colour.
     */
    drivingUsage: string;
    landUses: LandUse[];
}
export interface Dimension {
    /**
     * @description Abbreviation for the dimension, e.g. `ft` or `mÂ²`
     */
    abbr: string;
    /**
     * @description Multiply by this value for correct display to user
     */
    displayFactor: number;
    /**
     * @description Multiply by this value to store numbers correctly in db
     */
    storageFactor: number;
}
export interface Dimensions {
    one: Dimension;
    two: Dimension;
    three: Dimension;
}
export type TopView = '2D' | '2.5D' | '3D';
export interface PresentationLink {
    url: string;
    text: string;
}
export type DrawTool = {
    tool: 'ProjectBoundary' | 'Grid' | 'Labeller' | 'MapSelector' | 'mapQuery' | 'LineString' | 'Point' | 'Rectangle' | 'BPMove' | 'BPRotate' | 'Polygon' | 'ChildPolygon' | 'GeometryFilterBoundary' | null;
    defaultProps: object;
};
export type GiraffeOverLays = 'UsageEditor' | 'UsageTable' | 'MyLayers' | 'NewLayer' | 'ProjectSettings' | 'Screenshot' | 'DerivateEditor' | 'AppJSONEditor' | 'LayerSettings';
export type UserSuggestion = null | 'drawBuilding' | 'drawOffsetBuilding' | 'Rectangle' | 'drawRectSecondPoint' | 'drawRectExtrudeSide' | 'Point' | 'Polygon' | 'LineString' | 'drawPolySecondPoint' | 'drawVectorSecondPoint' | 'drawPolyLastPoint' | 'drawLineStringLastPoint' | 'Grid' | 'Labeller' | 'rotating' | 'resizing' | 'extruding';
export type LeftBarContent = 'PropertyEditor' | 'LayerControl' | 'Vistas';
export type RightBarContent = 'data' | 'Create Vector Layer' | 'Create Image Layer' | 'Esri Service Import' | 'WMS Import' | 'Mapbox Studio Import' | 'Advanced Layer Editor';
export interface Vista {
    id: number | 'new';
    name: string;
    project: number | string;
    details: {
        name: string;
        camera: Camera & {
            longitude?: number;
            latitude?: number;
        };
        topView: TopView;
        /**
         * url of image
         */
        snapShot: string;
        layerTree: LayerTree;
        solarDate: string;
        activeLayer: string;
        order?: number;
        description?: string;
    };
}
export interface ProjectCoreSnapEvent {
    data: {
        source: 'gi-core-evt';
        type: 'snap-update';
        mouseLng: number;
        mouseLat: number;
        ignoreSnapIds: FeatureId[];
        mapFeatures: {
            geometry: GeoJsonFeature['geometry'];
        }[];
        gridDef: {
            origin: GeoCoordinate | null;
            distance: number;
            bearing: number;
            enabled: boolean;
        };
    };
}
export interface ProjectCoreGeomEvent {
    data: {
        source: 'gi-core-evt';
        type: 'geometry-update';
        projectBoundary: ProjectBoundary | NullProjectBoundary;
        rawSections?: Record<FeatureId, RawSection>;
        projectAppsByAppID?: Record<string, ProjectApp>;
        projectionOrigin?: GeoCoordinate;
        layerTree?: LayerTree;
        invisibleDrawingLayers?: Set<string>;
        includesAllSections?: boolean;
        deleteSectionIds?: string[];
        terrainSettings?: ProjectTerrainSettings;
    };
}
export interface ProjectCoreTerrainEvent {
    data: {
        source: 'gi-core-evt';
        type: 'terrain-update';
        terrainData: {
            key: string;
            tiles: Tile[];
        };
    };
}
export interface ProjectCoreComputeCutFillEvent {
    data: {
        source: 'gi-core-evt';
        type: 'compute-cut-fill';
    };
}
export interface ProjectCoreOptimizeCutFillEvent {
    data: {
        source: 'gi-core-evt';
        type: 'optimize-cut-fill';
        features: Array<{
            section: StackedSection;
            fixed: boolean;
        }>;
    };
}
export type ProjectCoreWorkerEvent = ProjectCoreSnapEvent | ProjectCoreGeomEvent | ProjectCoreTerrainEvent | ProjectCoreComputeCutFillEvent | ProjectCoreOptimizeCutFillEvent;
export type StackedSectionSummary = {
    maxHeight: number;
    minHeight: number;
    doesStack: boolean;
    minBaseElevation: number;
    minElevationDatum: number;
};
export type FeaturePipelineUpdate = {
    newAndUpdatedStackedSections: Record<FeatureId, StackedSection[]>;
    sectionSummaryUpdates: Record<FeatureId, StackedSectionSummary>;
};
export type StackedSectionUpdate = FeaturePipelineUpdate & {
    exitIds?: FeatureId[];
    projectBounds?: BBox;
    terrain?: TerrainState<JSON>;
};
export type TerrainStateItem<TMeshType> = {
    mesh: TMeshType;
    originalTile: Tile;
    modifiedTile?: Tile;
    alphaMap?: Tile;
};
export type TerrainState<TMeshType> = {
    key: string;
    values: TerrainStateItem<TMeshType>[];
    elevationRange: [number, number];
};
export type TerrainUpdate = FeaturePipelineUpdate & {
    terrain: TerrainState<JSON>;
};
export type SnappedPointUpdate = {
    snapToPoint: GeoCoordinate;
};
export declare type FeatureCalcCategory = 'general' | 'subdivision' | 'apartment' | 'grid' | 'carpark';
export declare type FeatureCalcProperty = 'area' | 'length' | 'points' | 'xGrids' | 'yGrids' | 'lots' | 'avgLotArea' | 'avgLotFrontage' | 'apartments' | 'apartmentCores' | 'apartmentCoreArea' | 'avgApartmentArea' | 'bays';
export interface FeatureCalcResult {
    property: FeatureCalcProperty;
    value: number;
    category?: FeatureCalcCategory;
    units?: Units;
}
export type TileID = [x: number, y: number, z: number];
export type Tile = {
    width: number;
    pixels: ArrayLike<number>;
    tileID: TileID;
    minElevation?: number;
    maxElevation?: number;
};
export {};
