import { StackedSection } from '.';
import { CategoricalPalette } from './kanbans';
type LayerId = string;
type TabId = string;
type CategoryId = string;
type MeasureId = string;
type UsageName = string;
export interface Unit {
    id: string;
    abbreviation: string;
    displayName: string;
    /**
     * unmodifiable by user. e.g. length dimensions 1 to 3, currency
     */
    isSystemUnit?: boolean;
    /**
     * when show subtotals is on, should this be shown?
     */
    isSubtotalled: boolean;
    /**
     * hide from menus, useful if you're using metric and want nothing to do with imperial
     */
    isHidden: boolean;
}
export interface CounterFields {
    categories: Record<string, Category>;
    tabs: Record<string, CounterTab>;
    units: Record<string, Unit>;
    measures: Array<Measure>;
    display: {
        columnOrder: Array<LayerId>;
        tabOrder: Array<TabId>;
        tabCategoryOrder: Record<TabId, Array<CategoryId>>;
        categoryUsageOrders: Record<CategoryId, Array<UsageName>>;
        categoryUsageRowOrders: Record<CategoryId, Record<UsageName, Array<MeasureId>>>;
        areaChart: {
            show: boolean;
            areaType: 'grossArea' | 'netArea';
        };
        splitByLayer: boolean;
        showUnitTotals: boolean;
        hiddenLayers: Array<string>;
    };
}
export interface Token {
    token: string;
    type: number;
    value?: string | ((a: number, b?: number) => number) | undefined;
    show: string;
    preced?: number | undefined;
}
export type ParsedComponent = {
    pronumeral: string;
    label: string;
    value: number | null;
    featureIds?: string[];
};
export type FormulaResult = {
    error: string;
    value: number;
    missing: Array<string>;
    parsedComponents: Array<ParsedComponent>;
    quantity: number | null;
    rate: number | null;
};
export interface SectionsSplitByLandUse {
    asArray: StackedSection[];
    asObject: Record<string, StackedSection>;
}
/**
 * measure solved per feature
 */
export interface SolvedFeature extends FormulaResult {
    /**
     * feature usage
     */
    usage: string;
    /**
     * will be overwritten when not split by layer with `__COMBINED`
     */
    layerId: string;
    featureId: string;
}
export interface SolvedColumn {
    error: string;
    missing: string[];
    value: number;
    layerId: string;
    /**
     * direct for looped feature measures
     */
    solvedFeatures: SolvedFeature[];
    /**
     * direct for unlooped global measures
     */
    globalComponents: ParsedComponent[];
    quantity?: number | null;
    rate?: number | null;
}
export interface SolvedCombinedRow {
    measure: Measure;
    usages: Set<string>;
    columns: Array<SolvedColumn>;
}
/**
 * usage key is `__COMBINED` if not split by usage
 */
export interface GroupedSolvedCombinedRows {
    [categoryId: string]: Group;
}
export interface SolvedRow {
    usages: Set<string>;
    columns: Array<SolvedColumn>;
}
export interface SolvedMeasure {
    measure: Measure;
    /**
     * per-feature split (if applicable to measure)
     */
    features: Array<SolvedFeature>;
    rows: SolvedRow[];
}
export interface UsageInGroup {
    rows: SolvedCombinedRow[];
    unitTotals: GroupUnitTotals;
}
export interface Group {
    id: string;
    color: string;
    label: string;
    usages: {
        [usage: string]: UsageInGroup;
    };
}
export type GroupUnitTotals = {
    [unitId: string]: Array<GroupUnitTotalColumn>;
};
export type GroupUnitTotalColumn = {
    layerId: string;
    total: number;
};
export type GroupedRows = Record<string, Group>;
export type GroupedBy = 'category' | 'usage';
export type GroupOrders = {
    [id: string]: Array<string>;
};
export type ComponentType = 'rawProperty' | 'lineItem' | 'subtotal' | 'site';
export type ComponentSubType = 'measure' | 'derivativeLineItem' | 'site' | 'derivativeCategory' | 'unitInCategory';
/**
 * applied when the value of a particular property from a section is targeted
 */
export interface PropertyComponentType {
    type: 'rawProperty';
    subType: 'property';
    /**
     * id is the key of the property on the usage
     */
    id: string;
}
/**
 * applied when the targeted measure is an existing measure with no other measure dependencies
 */
export interface ExistingMeasureComponent {
    type: 'lineItem';
    subType: 'measure';
    id: string;
}
/**
 * applied when the targeted measure depends other measure(s) itself
 */
export interface DerivativeLineItemComponentType {
    type: 'lineItem';
    subType: 'derivativeLineItem';
    id: string;
}
/**
 * applied when the targeted measure is a subtotal
 */
export interface DerivativeCategoryComponentType {
    type: 'lineItem';
    subType: 'derivativeCategory';
    id: string;
}
/**
 * applied when the a site value is targeted (like total building area, site ex-building etc)
 */
export interface SiteComponentType {
    type: 'site';
    subType: 'site';
    siteKey: keyof CounterSiteAreas;
}
/**
 * applied when a subtotal of a unit in a category is targeted.
 *
 * (without it having been explicitly created as an existing measure. in that case, it would be a `derivativeCategory`)
 */
export interface UnitInCategoryComponentType {
    type: 'subtotal';
    subType: 'unitInCategory';
    categoryId: string;
    unitId: string;
}
export type LineItemComponentType = ExistingMeasureComponent | DerivativeLineItemComponentType | DerivativeCategoryComponentType;
export type MeasureComponentType = PropertyComponentType | LineItemComponentType | UnitInCategoryComponentType | SiteComponentType;
/**
 * Defines calculation of feature properties.
 *
 */
export interface Measure {
    id: string;
    unitId: string;
    categoryId: string;
    name: string;
    detail: string;
    tags?: string[];
    /**
     * if entries exists, the calculation is done for specific usages only. otherwise if empty, it is applied to every feature
     */
    appliedToUsages: string[];
    components: Array<MeasureComponentType>;
    formula: string;
    operation: BuiltInOperation;
    /**
     * in table display
     */
    isBold: boolean;
    /**
     * for example to support some measures that might be used for calcualtion purpose only.
     */
    isHidden: boolean;
    /**
     * text portion of the formula that represents a quantity
     */
    quantity?: {
        match: string;
        unitId: string;
    } | null;
    /**
     * text portion of the formula that represents a rate
     */
    rate?: {
        match: string;
        unitId: string;
    } | null;
}
export interface CounterTab {
    id: string;
    label: string;
    color: string;
}
export type ChartCommon = {
    reportTotal?: boolean;
    reportPercentages?: boolean;
    title?: string;
    /**
     * TODO, currently defaults to decreasing opacities of the category color
     */
    palettes?: {
        [layerId: string]: CategoricalPalette;
    };
    measures: {
        type: 'include' | 'exclude';
        ids: string[];
    };
};
export type ChartPie = ChartCommon & {
    type: 'pie';
};
export type ChartBar = ChartCommon & {
    type: 'bar';
};
export type MeasureChartType = ChartPie | ChartBar;
export type TableDisplay = {
    type: 'table';
    title?: string;
};
export interface Category {
    id: string;
    label: string;
    color: string;
    /**
     * Counter tab(s) to which this category belongs - id ref
     */
    tabs: string[];
    /**
     * should the category have its measures duplicated (where required) and subcategorised into usages:
     *
     * e.g.
     *
     * FINANCIAL
     *
     * - Residential
     *
     *   - Build cost: X -- same measure, only residential features used
     * - Community
     *
     *   - Build cost: Y -- same measure, only community features used
     *
     * instead of default:
     *
     * FINANCIAL
     *
     * - Build cost: X + Y -- same measure, all features of all usages combined
     */
    subcategorizeByUsage: boolean;
    isClosed: boolean;
    displays?: (MeasureChartType | TableDisplay)[] | null;
}
export type ItemType = 'per feature' | 'from measures' | 'subtotal';
export type BuiltInOperation = 'SUM' | 'CONSTANT' | 'AVERAGE' | 'MIN' | 'MAX' | 'COUNT';
export declare const emptyAnalyticsSite: {
    landscape: number;
    rooftopLandscape: number;
    road: number;
    paved: number;
    building: number;
    site: number;
    unionAll: number;
    siteExBuilding: number;
    siteExAll: number;
    METERS_2__landscape: number;
    METERS_2__rooftopLandscape: number;
    METERS_2__road: number;
    METERS_2__paved: number;
    METERS_2__building: number;
    METERS_2__site: number;
    METERS_2__unionAll: number;
    METERS_2__siteExBuilding: number;
    METERS_2__siteExAll: number;
    FEET_2__landscape: number;
    FEET_2__rooftopLandscape: number;
    FEET_2__road: number;
    FEET_2__paved: number;
    FEET_2__building: number;
    FEET_2__site: number;
    FEET_2__unionAll: number;
    FEET_2__siteExBuilding: number;
    FEET_2__siteExAll: number;
};
export type CounterSiteAreas = typeof emptyAnalyticsSite;
export type SiteProperty = keyof CounterSiteAreas;
export declare const SiteProperty: Record<keyof CounterSiteAreas, keyof CounterSiteAreas>;
export type CombinedCounterSiteAreas = {
    __byLayer: false;
    data: CounterSiteAreas;
};
export type CounterSiteAreasByLayer = {
    __byLayer: true;
    data: {
        [layerId: string]: CounterSiteAreas;
    };
};
export {};
