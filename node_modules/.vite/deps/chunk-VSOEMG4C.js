import {
  __commonJS
} from "./chunk-EWTE5DHJ.js";

// node_modules/@gi-nx/mini-iframe-rpc/src/errors/mini-iframe-error.js
var require_mini_iframe_error = __commonJS({
  "node_modules/@gi-nx/mini-iframe-rpc/src/errors/mini-iframe-error.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MiniIframeError = void 0;
    var MiniIframeError = class _MiniIframeError extends Error {
      // tslint:disable-next-line:no-any
      constructor(message, state) {
        super(message);
        this.timestamp = +/* @__PURE__ */ new Date();
        if (state) {
          Object.assign(this, state);
        }
        Object.setPrototypeOf(this, new.target.prototype);
        this.name = _MiniIframeError.name;
      }
    };
    exports.MiniIframeError = MiniIframeError;
  }
});

// node_modules/@gi-nx/mini-iframe-rpc/src/errors/remote-error.js
var require_remote_error = __commonJS({
  "node_modules/@gi-nx/mini-iframe-rpc/src/errors/remote-error.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RemoteError = exports.errorToJSON = void 0;
    var mini_iframe_error_1 = require_mini_iframe_error();
    function errorToJSON(err) {
      const { message, name, stack } = err;
      return Object.assign({ message, stack, name }, err);
    }
    exports.errorToJSON = errorToJSON;
    var causeToMessage = (cause) => {
      if (typeof cause === "string") {
        return cause;
      } else {
        return `${cause.message}`;
      }
    };
    var RemoteError = class _RemoteError extends mini_iframe_error_1.MiniIframeError {
      constructor(cause) {
        super(causeToMessage(cause));
        this.cause = typeof cause === "string" ? cause : errorToJSON(cause);
        this.name = _RemoteError.name;
      }
    };
    exports.RemoteError = RemoteError;
  }
});

// node_modules/@gi-nx/mini-iframe-rpc/src/errors/evaluation-error.js
var require_evaluation_error = __commonJS({
  "node_modules/@gi-nx/mini-iframe-rpc/src/errors/evaluation-error.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EvaluationError = void 0;
    var remote_error_1 = require_remote_error();
    var EvaluationError = class _EvaluationError extends remote_error_1.RemoteError {
      constructor(error) {
        super(error.cause);
        this.name = _EvaluationError.name;
      }
    };
    exports.EvaluationError = EvaluationError;
  }
});

// node_modules/@gi-nx/mini-iframe-rpc/src/errors/is-error.js
var require_is_error = __commonJS({
  "node_modules/@gi-nx/mini-iframe-rpc/src/errors/is-error.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isError = void 0;
    var isError = (rejectOrError) => {
      const isErrorValue = rejectOrError !== null && rejectOrError !== void 0 && (rejectOrError instanceof Error || rejectOrError instanceof DOMException || // DataCloneErrors must be identified as such otherwise, we can't even send errors
      // when response cant be serialized! This is required for MS Edge support.
      rejectOrError.name === "DataCloneError" || rejectOrError.message && typeof rejectOrError.message === "string" && rejectOrError.stack && typeof rejectOrError.stack === "string");
      return isErrorValue;
    };
    exports.isError = isError;
  }
});

// node_modules/@gi-nx/mini-iframe-rpc/src/errors/invocation-error.js
var require_invocation_error = __commonJS({
  "node_modules/@gi-nx/mini-iframe-rpc/src/errors/invocation-error.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InvocationError = void 0;
    var is_error_1 = require_is_error();
    var mini_iframe_error_1 = require_mini_iframe_error();
    var makeMessage = (procedureName, cause, previousRejectReasons) => {
      let message = `Error invoking remote procedure '${procedureName}'.`;
      if ((0, is_error_1.isError)(cause)) {
        message += ` ${cause.name}: ${cause.message}.`;
      } else if (cause) {
        message += ` Reason: ${cause.toString()}`;
      }
      if (previousRejectReasons && previousRejectReasons.length > 0) {
        const plural = previousRejectReasons.length > 1 ? "s" : "";
        message += ` ${previousRejectReasons.length} additional rejection${plural} from retried attempt${plural}.`;
      }
      return message;
    };
    var InvocationError = class _InvocationError extends mini_iframe_error_1.MiniIframeError {
      // tslint:disable-next-line:no-any
      constructor(procedureName, cause, previousRejectReasons) {
        super(makeMessage(procedureName, cause, previousRejectReasons));
        this.name = _InvocationError.name;
        this.procedureName = procedureName;
        this.cause = cause;
        this.previousRejectReasons = previousRejectReasons;
      }
    };
    exports.InvocationError = InvocationError;
  }
});

// node_modules/@gi-nx/mini-iframe-rpc/src/errors/procedure-not-found-error.js
var require_procedure_not_found_error = __commonJS({
  "node_modules/@gi-nx/mini-iframe-rpc/src/errors/procedure-not-found-error.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ProcedureNotFoundError = void 0;
    var remote_error_1 = require_remote_error();
    var ProcedureNotFoundError = class _ProcedureNotFoundError extends remote_error_1.RemoteError {
      constructor(state) {
        super(`Remote procedure '${state.procedureName}' not registered in remote RPC instance.`);
        this.procedureName = "unknown";
        if (state.procedureName) {
          this.procedureName = state.procedureName;
        }
        this.name = _ProcedureNotFoundError.name;
      }
    };
    exports.ProcedureNotFoundError = ProcedureNotFoundError;
  }
});

// node_modules/@gi-nx/mini-iframe-rpc/src/errors/send-message-error.js
var require_send_message_error = __commonJS({
  "node_modules/@gi-nx/mini-iframe-rpc/src/errors/send-message-error.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SendMessageError = void 0;
    var remote_error_1 = require_remote_error();
    var SendMessageError = class _SendMessageError extends remote_error_1.RemoteError {
      constructor(error) {
        super(error.cause);
        this.name = _SendMessageError.name;
      }
    };
    exports.SendMessageError = SendMessageError;
  }
});

// node_modules/@gi-nx/mini-iframe-rpc/src/errors/timeout-error.js
var require_timeout_error = __commonJS({
  "node_modules/@gi-nx/mini-iframe-rpc/src/errors/timeout-error.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TimeoutError = void 0;
    var mini_iframe_error_1 = require_mini_iframe_error();
    var TimeoutError = class _TimeoutError extends mini_iframe_error_1.MiniIframeError {
      constructor(state) {
        super(`Timeout after ${state.timeoutMilliSeconds} ms.`, state);
        this.timeoutMilliSeconds = 0;
        this.name = _TimeoutError.name;
      }
    };
    exports.TimeoutError = TimeoutError;
  }
});

// node_modules/@gi-nx/mini-iframe-rpc/src/errors/index.js
var require_errors = __commonJS({
  "node_modules/@gi-nx/mini-iframe-rpc/src/errors/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.deserializeRemoteError = exports.serializeRemoteError = exports.InvocationError = exports.RemoteError = exports.SendMessageError = exports.isError = exports.TimeoutError = exports.EvaluationError = exports.ProcedureNotFoundError = exports.MiniIframeError = void 0;
    var evaluation_error_1 = require_evaluation_error();
    Object.defineProperty(exports, "EvaluationError", { enumerable: true, get: function() {
      return evaluation_error_1.EvaluationError;
    } });
    var invocation_error_1 = require_invocation_error();
    Object.defineProperty(exports, "InvocationError", { enumerable: true, get: function() {
      return invocation_error_1.InvocationError;
    } });
    var is_error_1 = require_is_error();
    Object.defineProperty(exports, "isError", { enumerable: true, get: function() {
      return is_error_1.isError;
    } });
    var mini_iframe_error_1 = require_mini_iframe_error();
    Object.defineProperty(exports, "MiniIframeError", { enumerable: true, get: function() {
      return mini_iframe_error_1.MiniIframeError;
    } });
    var procedure_not_found_error_1 = require_procedure_not_found_error();
    Object.defineProperty(exports, "ProcedureNotFoundError", { enumerable: true, get: function() {
      return procedure_not_found_error_1.ProcedureNotFoundError;
    } });
    var remote_error_1 = require_remote_error();
    Object.defineProperty(exports, "RemoteError", { enumerable: true, get: function() {
      return remote_error_1.RemoteError;
    } });
    var send_message_error_1 = require_send_message_error();
    Object.defineProperty(exports, "SendMessageError", { enumerable: true, get: function() {
      return send_message_error_1.SendMessageError;
    } });
    var timeout_error_1 = require_timeout_error();
    Object.defineProperty(exports, "TimeoutError", { enumerable: true, get: function() {
      return timeout_error_1.TimeoutError;
    } });
    var errorMap = {};
    var remoteErrorClasses = [procedure_not_found_error_1.ProcedureNotFoundError, evaluation_error_1.EvaluationError, send_message_error_1.SendMessageError].reduce((obj, constr) => {
      obj[constr.name] = constr;
      return obj;
    }, errorMap);
    var serializeRemoteError = (cause, remoteExceptionName) => {
      const convert = (err) => {
        const errJSON = (0, remote_error_1.errorToJSON)(err);
        if (remoteExceptionName) {
          errJSON.name = remoteExceptionName;
        }
        return errJSON;
      };
      if (cause instanceof remote_error_1.RemoteError) {
        return convert(cause);
      }
      return convert(new remote_error_1.RemoteError(cause));
    };
    exports.serializeRemoteError = serializeRemoteError;
    var deserializeRemoteError = (error) => {
      const constr = remoteErrorClasses[error.name] || remote_error_1.RemoteError;
      return new constr(error);
    };
    exports.deserializeRemoteError = deserializeRemoteError;
  }
});

// node_modules/@gi-nx/mini-iframe-rpc/src/result-cache.js
var require_result_cache = __commonJS({
  "node_modules/@gi-nx/mini-iframe-rpc/src/result-cache.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ResultCache = exports.DEFAULT_RESULT_CACHE_CAPACITY = void 0;
    exports.DEFAULT_RESULT_CACHE_CAPACITY = 200;
    var DEFAULT_PARAMETERS = {
      capacity: exports.DEFAULT_RESULT_CACHE_CAPACITY
    };
    var ResultCache = class {
      constructor(config) {
        this.ids = [];
        this.results = {};
        this.config = Object.assign({}, DEFAULT_PARAMETERS, config || {});
      }
      hasCachedResult(id) {
        return Object.prototype.hasOwnProperty.call(this.results, id);
      }
      getCachedResult(id) {
        return this.results[id];
      }
      // tslint:disable-next-line:no-any
      setCachedResult(id, result) {
        if (this.hasCachedResult(id)) {
          this.ids = this.ids.filter((c) => c !== id);
        }
        this.ids.unshift(id);
        this.results[id] = result;
        if (this.config.capacity >= 0) {
          this.enforceCapacity();
        }
      }
      enforceCapacity() {
        for (let size = this.ids.length; size > this.config.capacity; size--) {
          const id = this.ids.pop();
          const result = this.results[id];
          delete this.results[id];
          if (this.config.evictionCallback) {
            this.config.evictionCallback(id, result);
          }
        }
      }
    };
    exports.ResultCache = ResultCache;
  }
});

// node_modules/@gi-nx/mini-iframe-rpc/src/transport/post-message-transport.js
var require_post_message_transport = __commonJS({
  "node_modules/@gi-nx/mini-iframe-rpc/src/transport/post-message-transport.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PostMessageTransport = void 0;
    var isInternetExplorer = () => (
      // based on https://stackoverflow.com/questions/24861073/detect-if-any-kind-of-ie-msie/24861307#24861307
      navigator.appName === "Microsoft Internet Explorer" || !!navigator.userAgent.match(/Trident|MSIE|rv:11/)
    );
    var POSTMESSAGE_TYPE = "mini-iframe-rpc";
    var DEFAULT_CONFIG = {
      // IE needs postmessages to contain strings instead of objects
      stringifyObjects: isInternetExplorer()
    };
    var PostMessageTransport = class {
      constructor(windowRef, onReceive, config) {
        this.recv = (messageEvent) => {
          if ((!this.config.originWhitelist || this.config.originWhitelist.length < 1 || this.config.originWhitelist.indexOf(messageEvent.origin) > -1) && messageEvent.data) {
            const messageData = this.readMessageData(messageEvent);
            if (messageData && messageData.type === POSTMESSAGE_TYPE && messageData.payload) {
              this.onReceive(messageData.payload, messageEvent.source, messageEvent.origin);
            }
          }
        };
        this.windowRef = windowRef || window;
        this.onReceive = onReceive;
        this.config = Object.assign({}, DEFAULT_CONFIG, config || {});
        this.windowRef.addEventListener("message", this.recv);
      }
      close() {
        this.windowRef.removeEventListener("message", this.recv);
      }
      send(recipient, messageBody) {
        return new Promise((resolve, reject) => {
          const envelopedMessage = {
            type: POSTMESSAGE_TYPE,
            payload: messageBody
          };
          recipient.targetWindow.postMessage(this.config.stringifyObjects ? JSON.stringify(envelopedMessage, (_k, v) => v === void 0 ? null : v) : envelopedMessage, recipient.targetOrigin || "*");
          resolve();
        });
      }
      // tslint:disable-next-line:no-any
      readMessageData(messageEvent) {
        if (typeof messageEvent.data === "string" && JSON && isInternetExplorer()) {
          try {
            return JSON.parse(messageEvent.data);
          } catch (e) {
            return null;
          }
        }
        return messageEvent.data;
      }
    };
    exports.PostMessageTransport = PostMessageTransport;
  }
});

// node_modules/@gi-nx/mini-iframe-rpc/src/mini-iframe-rpc.js
var require_mini_iframe_rpc = __commonJS({
  "node_modules/@gi-nx/mini-iframe-rpc/src/mini-iframe-rpc.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MiniIframeRPC = exports.ResultCache = void 0;
    var errors_1 = require_errors();
    var result_cache_1 = require_result_cache();
    Object.defineProperty(exports, "ResultCache", { enumerable: true, get: function() {
      return result_cache_1.ResultCache;
    } });
    var post_message_transport_1 = require_post_message_transport();
    var RANDOM_BASE = 36;
    var CALLID_LENGTH = 8;
    var DEFAULT_INVOCATION_OPTIONS = {
      timeout: 10 * 60 * 1e3,
      retryLimit: 0,
      retryAllFailures: false,
      targetWindow: window.parent,
      targetOrigin: "*"
    };
    var MiniIframeRPC = class {
      constructor(initParameters) {
        this.events = [];
        this.callbacks = {};
        this.registeredProcedures = {};
        this.recv = (messageBody, messageSource, messageOrigin) => {
          this.internalEventCallback("onReceive", messageBody, messageSource, messageOrigin);
          if ("method" in messageBody) {
            this.handleRequest(messageBody, messageSource, messageOrigin);
          } else {
            this.handleResponse(messageBody);
          }
        };
        this.config = {
          windowRef: initParameters && initParameters.windowRef || window,
          originWhitelist: initParameters && initParameters.originWhitelist || [],
          defaultInvocationOptions: Object.assign({}, DEFAULT_INVOCATION_OPTIONS, initParameters && initParameters.defaultInvocationOptions || {}),
          eventCallbacks: initParameters && initParameters.eventCallbacks || {},
          resultCacheCapacity: initParameters && typeof initParameters.resultCacheCapacity === "number" ? initParameters.resultCacheCapacity : result_cache_1.DEFAULT_RESULT_CACHE_CAPACITY
        };
        this.resultCache = new result_cache_1.ResultCache({
          capacity: this.config.resultCacheCapacity,
          evictionCallback: (id, result) => {
            this.internalEventCallback("onResultCacheEviction", id, result);
          }
        });
        this.transport = new post_message_transport_1.PostMessageTransport(this.config.windowRef, this.recv, {
          originWhitelist: this.config.originWhitelist
        });
      }
      register(procedureName, implementation) {
        this.internalEventCallback("onRegister", procedureName, implementation);
        if (implementation) {
          this.registeredProcedures[procedureName] = implementation;
        } else {
          delete this.registeredProcedures[procedureName];
        }
      }
      invoke(method, params, invocationOptions) {
        var _a, _b;
        const options = Object.assign({}, this.config.defaultInvocationOptions, invocationOptions || {});
        const targetWindow = (_a = options.targetWindow) !== null && _a !== void 0 ? _a : DEFAULT_INVOCATION_OPTIONS.targetWindow;
        const targetOrigin = (_b = options.targetOrigin) !== null && _b !== void 0 ? _b : DEFAULT_INVOCATION_OPTIONS.targetOrigin;
        const id = this.getNextCallId();
        const requestMessageBody = {
          id,
          method,
          params: params || []
        };
        return this.requestWithRetry(targetWindow, targetOrigin, requestMessageBody, options);
      }
      close() {
        this.internalEventCallback("onClose");
        this.transport.close();
      }
      requestWithRetry(targetWindow, targetOrigin, requestMessageBody, options) {
        let requestCount = 0;
        let failureCount = 0;
        let finalResolve = () => void 0;
        let finalReject = () => void 0;
        let completed = false;
        const previousRejectReasons = [];
        const isErrorRetriable = (error) => {
          if (options.timeout <= 0 || options.retryLimit < 1) {
            return false;
          }
          return options.retryAllFailures || error instanceof errors_1.TimeoutError;
        };
        const makeRequest = () => __awaiter(this, void 0, void 0, function* () {
          return this.sendMessage(targetWindow, targetOrigin, requestMessageBody).then(() => new Promise((resolve, reject) => {
            this.callbacks[requestMessageBody.id] = { resolve, reject };
          }));
        });
        const handleResolve = (result) => {
          completed = true;
          finalResolve(result);
        };
        const handleReject = (reason) => {
          failureCount += 1;
          if (!completed && failureCount === requestCount) {
            if (isErrorRetriable(reason) && requestCount < options.retryLimit + 1) {
              this.internalEventCallback("onRequestRetry", reason, previousRejectReasons, requestMessageBody);
              previousRejectReasons.push(reason);
              makeAttempt();
            } else {
              completed = true;
              finalReject(new errors_1.InvocationError(requestMessageBody.method, reason, previousRejectReasons));
            }
          }
        };
        const makeAttempt = () => {
          requestCount += 1;
          let responsePromise = makeRequest();
          if (options.timeout > 0) {
            responsePromise = this.timeboxPromise(responsePromise, options.timeout);
          }
          responsePromise.then(handleResolve, handleReject);
        };
        const returnValue = new Promise((resolve, reject) => {
          finalResolve = resolve;
          finalReject = reject;
        });
        makeAttempt();
        return returnValue;
      }
      internalEventCallback(internalEventCallback, ...args) {
        const cb = this.config.eventCallbacks[internalEventCallback];
        if (cb) {
          cb.apply(this, args);
        }
      }
      timeboxPromise(originalPromise, timeoutMilliSeconds) {
        return Promise.race([
          originalPromise,
          new Promise((_resolve, reject) => {
            this.config.windowRef.setTimeout(() => reject(new errors_1.TimeoutError({ timeoutMilliSeconds })), timeoutMilliSeconds);
          })
        ]);
      }
      getNextCallId() {
        let randomId = null;
        while (!randomId || this.callbacks[randomId]) {
          randomId = `cb${Math.random().toString(RANDOM_BASE).replace(/[^a-z]+/g, "").substr(0, CALLID_LENGTH)}`;
        }
        return randomId;
      }
      sendMessage(targetWindow, targetOrigin, messageBody) {
        this.internalEventCallback("onSend", messageBody, targetWindow, targetOrigin);
        return this.transport.send({ targetWindow, targetOrigin }, messageBody);
      }
      isArray(arg) {
        return Object.prototype.toString.call(arg) === "[object Array]";
      }
      unpackParams(params) {
        if (this.isArray(params)) {
          return params;
        }
        if (params === void 0) {
          return [];
        }
        return [params];
      }
      handleRequest(requestMessageBody, messageSource, messageOrigin) {
        return __awaiter(this, void 0, void 0, function* () {
          this.events.push(/* @__PURE__ */ new Date());
          const id = requestMessageBody.id;
          const method = requestMessageBody.method;
          const params = this.unpackParams(requestMessageBody.params);
          const responseOrigin = !messageOrigin || messageOrigin === "null" ? null : messageOrigin;
          const sendError = (rejectOrError, exceptionName) => {
            const sendingError = (0, errors_1.isError)(rejectOrError);
            return this.sendMessage(messageSource, responseOrigin, {
              id,
              isErrorInstance: sendingError,
              error: sendingError ? (0, errors_1.serializeRemoteError)(rejectOrError, exceptionName) : rejectOrError
            });
          };
          const getResult = () => {
            if (this.resultCache.hasCachedResult(id)) {
              return this.resultCache.getCachedResult(id);
            }
            const resultPromise = new Promise((resolve) => {
              resolve(this.registeredProcedures[method].apply({ requestMessageBody, messageSource, messageOrigin }, params));
            });
            this.resultCache.setCachedResult(id, resultPromise);
            return resultPromise;
          };
          const now = /* @__PURE__ */ new Date();
          this.events = this.events.filter((e) => now - e < 1e3 * 60);
          const MAX_PER_MINUTE = 100;
          if (this.events.length > MAX_PER_MINUTE) {
            sendError(new Error(`Too many invocations, max of ${MAX_PER_MINUTE} per minute`));
          } else if (this.registeredProcedures[method]) {
            getResult().then((result) => this.sendMessage(messageSource, responseOrigin, {
              id,
              result
            }).catch((error) => sendError(error, errors_1.SendMessageError.name)), (error) => sendError(error, errors_1.EvaluationError.name));
          } else {
            sendError(new errors_1.ProcedureNotFoundError({ procedureName: method }));
          }
        });
      }
      handleResponse(messageBody) {
        const callbackFunctions = this.callbacks[messageBody.id];
        if (callbackFunctions) {
          delete this.callbacks[messageBody.id];
          if ("isErrorInstance" in messageBody) {
            const errorObject = messageBody.isErrorInstance ? (0, errors_1.deserializeRemoteError)(messageBody.error) : messageBody.error;
            callbackFunctions.reject(errorObject);
          } else if ("result" in messageBody) {
            callbackFunctions.resolve(messageBody.result);
          }
        } else {
          this.internalEventCallback("onUnexpectedResponse", messageBody);
        }
      }
    };
    exports.MiniIframeRPC = MiniIframeRPC;
  }
});

// node_modules/@gi-nx/mini-iframe-rpc/src/index.js
var require_src = __commonJS({
  "node_modules/@gi-nx/mini-iframe-rpc/src/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_mini_iframe_rpc(), exports);
  }
});

// node_modules/@gi-nx/iframe-sdk/src/lib/iframe-sdk.js
var require_iframe_sdk = __commonJS({
  "node_modules/@gi-nx/iframe-sdk/src/lib/iframe-sdk.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.rpc = exports.giraffeState = exports.GiraffeState = void 0;
    var mini_iframe_rpc_1 = require_src();
    var geoKeys = ["rawSections", "bakedSections", "projects", "selected"];
    function toGeoJSON(v) {
      if (Array.isArray(v))
        return { type: "FeatureCollection", features: v };
      const features = [];
      Object.values(v || {}).forEach((vs) => {
        if (Array.isArray(vs)) {
          vs.forEach((v2, vi) => {
            features.push({
              type: "Feature",
              // @ts-ignore
              geometry: v2.geometry,
              // @ts-ignore
              properties: Object.assign(Object.assign({}, v2.properties), {
                // @ts-ignore
                id: `${v2.properties.id}-${vi}`
              })
            });
          });
        } else {
          features.push(vs);
        }
      });
      return {
        type: "FeatureCollection",
        features
      };
    }
    var GiraffeState = class {
      constructor() {
        this.attr = {};
        this.listeners = {};
        this.listen();
      }
      get(key) {
        if (geoKeys.includes(key))
          return toGeoJSON(this.attr[key]);
        return this.attr[key];
      }
      set(key, value, event) {
        if (JSON.stringify(this.attr[key]) === JSON.stringify(value))
          return;
        this.attr[key] = value;
        Object.values(this.listeners).forEach((l) => {
          if (l.keys.includes(key))
            l.listener(key, event);
        });
      }
      addListener(keys, listener) {
        const listenerKey = (Math.random() + 1).toString(36).substring(2);
        this.listeners[listenerKey] = {
          keys,
          listener
        };
        return listenerKey;
      }
      removeListener(listenerKey) {
        delete this.listeners[listenerKey];
      }
      removeAllListeners() {
        this.listeners = {};
      }
      listen() {
        window.addEventListener("message", (event) => {
          let data = void 0;
          try {
            if (!event.data)
              return;
            if (event.data === "[object Object]")
              return;
            data = JSON.parse(event.data);
            if (data === null || data === void 0 ? void 0 : data.type) {
              this.set(data.type, data[data.type], event);
            }
          } catch (e) {
            console.log("error parsing message", e);
          }
        }, false);
      }
    };
    exports.GiraffeState = GiraffeState;
    exports.giraffeState = new GiraffeState();
    exports.rpc = new mini_iframe_rpc_1.MiniIframeRPC();
  }
});

// node_modules/@gi-nx/iframe-sdk/src/index.js
var require_src2 = __commonJS({
  "node_modules/@gi-nx/iframe-sdk/src/index.js"(exports) {
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_iframe_sdk(), exports);
  }
});

export {
  require_src2 as require_src
};
//# sourceMappingURL=chunk-VSOEMG4C.js.map
